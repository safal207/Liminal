# Карта архитектуры проекта "Resonance Liminal"

Этот документ представляет собой высокоуровневый обзор архитектуры системы "Resonance Liminal". Он предназначен для архитекторов, ведущих разработчиков и всех, кто хочет понять, как устроена система и как ее компоненты взаимодействуют друг с другом.

## Ключевые принципы архитектуры

*   **Прагматичная эволюция:** Система развивается итеративно, отталкиваясь от текущей стабильной реализации (Python/FastAPI) к более амбициозному видению (Haskell/Elixir), как это отражено в `README.md`.
*   **Гибкость ML-компонентов:** Архитектура намеренно избегает привязки к конкретным моделям ИИ через использование "универсального адаптера" и стандартного формата ONNX.
*   **Встроенная наблюдаемость (Observability):** Мониторинг и сбор метрик (Prometheus, Grafana) являются неотъемлемой частью системы с самого начала, а не запоздалой мыслью.

## Диаграмма архитектуры (C4 Model: Container Diagram)

Эта диаграмма показывает основные работающие контейнеры (сервисы) в системе и их взаимодействие.

```mermaid
C4Container
  title Архитектура системы "Resonance Liminal"

  Person(user, "Пользователь", "Человек, использующий платформу для саморазвития.")

  System_Boundary(c1, "Система Resonance Liminal (развернута в Docker)") {
    Container(frontend, "Фронтенд", "HTML, JS, CSS", "Статический веб-интерфейс для мониторинга состояний сознания в реальном времени.")
    Container(backend, "Бэкенд API", "Python, FastAPI", "Обрабатывает бизнес-логику, предоставляет REST и GraphQL API.")
    ContainerDb(neo4j, "Графовая БД", "Neo4j", "Хранит узлы и связи графа состояний сознания.")
    ContainerDb(redis, "Кэш и Шина сообщений", "Redis", "Кэширует сессии, временные данные и может использоваться для Pub/Sub.")
    Container(ml_adapter, "ML Адаптер", "Python, ONNX Runtime", "Запускает ML-модели в формате ONNX для получения инференса.")
    
    System_Boundary(observability, "Подсистема мониторинга") {
      Container(prometheus, "Prometheus", "Prometheus", "Собирает и хранит метрики со всех сервисов.")
      Container(grafana, "Grafana", "Grafana", "Визуализирует метрики в виде дашбордов.")
    }
  }

  # Взаимодействия
  user -> frontend: "Использует интерфейс в браузере"
  frontend -> backend: "REST (начальная загрузка), WebSocket (GraphQL подписки)"
  
  backend -> neo4j: "Читает и пишет данные графа (Bolt)"
  backend -> redis: "Читает и пишет в кэш"
  backend -> ml_adapter: "Запрашивает предсказания моделей"

  prometheus -> backend: "Собирает метрики с эндпоинта /metrics"
  grafana -> prometheus: "Запрашивает данные для дашбордов"

```

## Описание компонентов

| Компонент | Технология | Описание |
|---|---|---|
| **Фронтенд** | HTML, CSS, JavaScript | Набор статических страниц (`consciousness_monitor.html`), которые напрямую взаимодействуют с бэкендом. Не использует тяжелые фреймворки. Получает данные в реальном времени через WebSocket. |
| **Бэкенд API** | Python, FastAPI | Ядро системы. Предоставляет асинхронный API. Управляет аутентификацией (JWT), бизнес-логикой, взаимодействием с базами данных и ML-моделями. |
| **Графовая БД** | Neo4j | Основное хранилище данных. Идеально подходит для моделирования сложных взаимосвязей между состояниями сознания, эмоциями и событиями. |
| **Кэш** | Redis | Используется для быстрых операций: хранение сессий, кэширование часто запрашиваемых данных. |
| **ML Адаптер** | Python, ONNX Runtime | Отдельный сервис или модуль, отвечающий за запуск моделей машинного обучения. Принимает данные от бэкенда и возвращает результат предсказания. |
| **Prometheus** | Prometheus | Сервис мониторинга, который периодически опрашивает (`scrape`) эндпоинт `/metrics` на бэкенде и других сервисах для сбора данных о их производительности и состоянии. |
| **Grafana** | Grafana | Платформа для визуализации. Подключена к Prometheus и отображает собранные метрики на преднастроенных дашбордах. |

## Ключевые потоки данных

### 1. Загрузка и отображение дашборда

1.  **Пользователь** открывает `consciousness_monitor.html` в браузере.
2.  **Фронтенд (JS)** отправляет `GET` запрос на REST эндпоинт бэкенда (например, `/api/consciousness/graph`) для получения начального состояния графа.
3.  **Бэкенд** запрашивает данные из **Neo4j**, формирует ответ и отправляет его на фронтенд.
4.  Одновременно **Фронтенд** устанавливает **WebSocket** соединение с GraphQL эндпоинтом бэкенда (`/graphql/subscriptions`).
5.  **Бэкенд** подтверждает подписку. Теперь фронтенд готов получать обновления в реальном времени.

### 2. Переход между состояниями (Real-time update)

1.  В системе происходит событие (например, симулированное пользователем или инициированное внутренним триггером).
2.  **Бэкенд** обрабатывает событие, обновляет данные в **Neo4j**.
3.  **Бэкенд** публикует информацию о событии (например, `CONSCIOUSNESS_TRANSITION`) через **GraphQL подписку**.
4.  **Фронтенд** получает событие по WebSocket и динамически обновляет интерфейс (например, подсвечивает новый активный узел в графе).
